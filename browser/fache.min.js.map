{"version":3,"file":"fache.min.js","sources":["../src/fache.js"],"sourcesContent":["/**\r\n * Fetch and cache the response\r\n */\r\n( function () {\r\n\r\n    const DEFAULT_CACHE_LIFETIME = 60;\r\n\r\n    class FacheManager {\r\n\r\n        /**\r\n         * Constructor \r\n         * \r\n         */\r\n        constructor() {\r\n\r\n            this.cachedPairs = [];\r\n        }\r\n\r\n        /**\r\n         * Validate and normalize init settings\r\n         *\r\n         * @param {Object} init - Initial settings\r\n         * @param {function|number|undefined} seconds - Lifetime of cache. If function, then should\r\n         *                                              return a number type\r\n         *\r\n         * @return {Object} Normalized settings with default values\r\n         */\r\n        normalizeInitSettings( init ) {\r\n\r\n            if ( typeof init !== 'undefined' && typeof init !== 'object' ) {\r\n\r\n                throw new FacheError( '`init` should be an object or undefined' );\r\n            }\r\n\r\n            let defaultSettings = {\r\n\r\n                seconds: DEFAULT_CACHE_LIFETIME,\r\n                method: 'GET'\r\n            };\r\n\r\n            let settings = Object.assign( {}, defaultSettings, init );\r\n\r\n            settings.method = settings.method.toUpperCase();\r\n\r\n            if ( typeof settings.seconds === 'number' ) {\r\n                \r\n                settings.getCacheLifeTime = resposne => settings.seconds;\r\n            }\r\n            else if ( typeof settings.seconds === 'function' ) {\r\n\r\n                settings.getCacheLifeTime = settings.seconds;\r\n            }\r\n\r\n            return settings;\r\n        }\r\n\r\n        /**\r\n         * Fetch by URL or a Request object, then cache the response. Note that it only caches GET\r\n         * requests.\r\n         *\r\n         * @param {string|Object} urlOrRequest - A URL string or a Request object\r\n         * @param {Object} settings - Contains both settings of Fetch API and settings of \r\n         *                            cache method\r\n         * @returns {Promise} A fetched promise with a cloned response\r\n         */\r\n        cache( urlOrRequest, settings ) {\r\n\r\n            let request = this.pickRequest( urlOrRequest );\r\n\r\n            if ( settings.method !== 'GET' ) {\r\n\r\n                return fetch( request, settings );\r\n            }\r\n\r\n            let reqResPair = new RequestResponsePair( request );\r\n\r\n            this.cachedPairs.push( reqResPair );\r\n            reqResPair.fetchPromise = fetch( request, settings );\r\n            \r\n            return reqResPair.fetchPromise.then( response => { \r\n\r\n                reqResPair.response = response.clone();\r\n\r\n                let cacheLifeTime = settings.getCacheLifeTime( response.clone() );\r\n\r\n                if ( cacheLifeTime > 0 ) {\r\n\r\n                    reqResPair.invalidateResponse( \r\n                        cacheLifeTime, \r\n                        () => this.removePair( reqResPair )\r\n                    );\r\n                }\r\n                else {\r\n\r\n                    this.removePair( reqResPair );\r\n                }\r\n\r\n                return response.clone();\r\n            } );\r\n        }\r\n\r\n        /**\r\n         * Look up for a RequsetResponsePair object. If not found or expired, then start fetch\r\n         * and cache again. Otherwise return the exiting fetch promise.\r\n         *\r\n         * @param {string|Object} - Same as cache method\r\n         * @param {Object} - Same as `settings` in cache method\r\n         */\r\n        promiseGetResponse( urlOrRequest, init ) {\r\n\r\n            let settings = this.normalizeInitSettings( init );\r\n            let reqResPair = this.getPair( urlOrRequest );\r\n\r\n            if ( reqResPair === null ) {\r\n\r\n                return this.cache( urlOrRequest, settings );\r\n            }\r\n\r\n            return reqResPair.fetchPromise.then( response => response.clone() );\r\n        }\r\n\r\n        pickRequest( urlOrRequest ) {\r\n\r\n            let request = null;\r\n\r\n            if ( typeof urlOrRequest === 'string' ) {\r\n\r\n                request = new Request( urlOrRequest );\r\n            }\r\n            else if ( urlOrRequest instanceof Request ) {\r\n\r\n                request = urlOrRequest;\r\n            }\r\n            else {\r\n\r\n                throw new FacheError( 'Require a URL or a Request instance.' );\r\n            }\r\n\r\n            return request;\r\n        }\r\n\r\n        pickUrl( urlOrRequest ) {\r\n\r\n            let url = '';\r\n\r\n            if ( typeof urlOrRequest === 'string' ) {\r\n\r\n                // URL could be a relative path. Make it to a full path.\r\n                url = new Request( urlOrRequest ).url;\r\n            }\r\n            else if ( urlOrRequest instanceof Request ) {\r\n\r\n                url = urlOrRequest.url;\r\n            }\r\n            else {\r\n\r\n                throw new FacheError( 'Require a URL or a Request instance.' );\r\n            }\r\n\r\n            return url;\r\n        }    \r\n\r\n        getPair( urlOrRequest ) {\r\n\r\n            let url = this.pickUrl( urlOrRequest );\r\n\r\n            for ( let i = 0; i < this.cachedPairs.length; i ++ ) {\r\n\r\n                if ( url === this.cachedPairs[i].url ) {\r\n\r\n                    return this.cachedPairs[i];\r\n                }\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        removePair( reqResPair ) {\r\n\r\n            let index = this.cachedPairs.indexOf( reqResPair );\r\n\r\n            if ( index >= 0 ) {\r\n\r\n                this.cachedPairs.splice( index, 1 );\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Remove all cached pairs. Means that all cached responses are invalidated.\r\n         */\r\n        clearAll() {\r\n\r\n            this.cachedPairs = [];\r\n        }\r\n\r\n        /**\r\n         * Clear a cached pair by URL or Request object\r\n         *\r\n         * @returns {number} Return index of the cachedPair or -1 when not found.\r\n         */\r\n        clear( urlOrRequest ) {\r\n\r\n            let url = '';\r\n            let request = null;\r\n            let i = 0;\r\n\r\n            if ( typeof urlOrRequest === 'string' ) {\r\n\r\n                url = new Request( urlOrRequest ).url;\r\n\r\n                for ( i = 0; i < this.cachedPairs.length; i ++ ) {\r\n\r\n                    if ( url === this.cachedPairs[i].url ) {\r\n\r\n                        this.cachedPairs.splice( i, 1 );\r\n                        return i;\r\n                    }\r\n                }\r\n            }\r\n            else if ( urlOrRequest instanceof Request ) {\r\n\r\n                requrest = urlOrRequest;\r\n\r\n                for ( i = 0; i < this.cachedPairs.length; i ++ ) {\r\n\r\n                    if ( request === this.cachedPairs[i].request ) {\r\n\r\n                        this.cachedPair.splice( i, 1 );\r\n                        return i;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    class RequestResponsePair {\r\n\r\n        constructor( request ) {\r\n\r\n            if ( request instanceof Request === false) {\r\n\r\n                throw new FacheError( 'Require an instance of Request or RequestRef.' );\r\n            }\r\n\r\n            this.request = request;\r\n            this.url = this.request.url;\r\n            this.response = null;\r\n            this.fetchPromise = null;\r\n        }\r\n\r\n        invalidateResponse( seconds, onCacheExpire ) {\r\n\r\n            if ( seconds <= 0 ) {\r\n\r\n                return;\r\n            }\r\n\r\n            setTimeout( () => {\r\n                \r\n                onCacheExpire( this );\r\n\r\n            }, seconds * 1000 );\r\n        }\r\n    } \r\n\r\n    class FacheError extends Error {\r\n\r\n        constructor( message ) {\r\n\r\n            super( `[Fache] ${message}\\n` );\r\n            this.name = this.constructor.name;\r\n\r\n            if ( typeof Error.captureStackTrace === 'function' ) {\r\n            \r\n                Error.captureStackTrace( this, this.constructor );\r\n\r\n            } else {\r\n\r\n                this.stack = ( new Error( message ) ).stack; \r\n            }\r\n        }\r\n    }\r\n\r\n/* Main *******************************************************************************************/\r\n\r\n    let facheManager = new FacheManager();\r\n    let fache = ( urlOrRequest, init ) => facheManager.promiseGetResponse( urlOrRequest, init );\r\n\r\n/* Expose to window object ************************************************************************/\r\n\r\n    if ( typeof window === 'undefined' ) {\r\n\r\n        throw new FacheError( 'Fache runs only in the context of a browser.' );\r\n    }\r\n    else if ( window.fetch === undefined ) {\r\n\r\n        throw new FacheError( 'Fache requires Fetch API. Look for a polyfill.' );\r\n    }\r\n    else {\r\n\r\n        fache.manager = facheManager;\r\n        fache.FacheManager = FacheManager;\r\n        fache.clear = urlOrRequest => facheManager.clear( urlOrRequest );\r\n        fache.clearAll = () => facheManager.clearAll();\r\n\r\n        window.fache = fache;\r\n    }\r\n\r\n/* Expose to node application that runs in a browser e.g. React, Angular, Vue, etc ****************/\r\n\r\n    if ( typeof module !== 'undefined' ) {\r\n\r\n        module.exports = fache;\r\n    }\r\n\r\n} )();\r\n\r\n"],"names":["fache","urlOrRequest","init","facheManager","promiseGetResponse","FacheManager","cachedPairs","_typeof","FacheError","defaultSettings","seconds","method","settings","Object","assign","toUpperCase","getCacheLifeTime","resposne","request","this","pickRequest","fetch","reqResPair","RequestResponsePair","push","fetchPromise","then","response","clone","cacheLifeTime","invalidateResponse","_this","removePair","normalizeInitSettings","getPair","cache","Request","url","pickUrl","i","length","index","indexOf","splice","requrest","cachedPair","onCacheExpire","setTimeout","_this2","message","name","_this3","constructor","Error","captureStackTrace","stack","window","undefined","manager","clear","clearAll","module","exports"],"mappings":"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"}